// api/poll.js
// Polling endpoint for long-running AssemblyAI transcriptions.
// The frontend calls this if the main /api/transcript timed out
// but returned a transcriptId.
//
// Usage: GET /api/poll?id=ASSEMBLYAI_TRANSCRIPT_ID

const ASSEMBLYAI_KEY = process.env.ASSEMBLYAI_API_KEY || '';

export default async function handler(req, res) {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
  if (req.method === 'OPTIONS') return res.status(200).end();

  const transcriptId = req.query.id;
  if (!transcriptId || !ASSEMBLYAI_KEY) {
    return res.status(400).json({ error: 'Missing transcript ID or API key' });
  }

  try {
    const pollRes = await fetch(`https://api.assemblyai.com/v2/transcript/${transcriptId}`, {
      headers: { 'Authorization': ASSEMBLYAI_KEY },
    });

    if (!pollRes.ok) {
      return res.status(500).json({ error: 'Failed to check transcription status' });
    }

    const pollData = await pollRes.json();

    if (pollData.status === 'completed') {
      const segments = groupWordsIntoSegments(pollData.words || [], pollData.text);

      return res.status(200).json({
        status: 'completed',
        title: `Transcription ${transcriptId}`,
        videoId: null,
        language: pollData.language_code || 'unknown',
        isAutoGenerated: false,
        isSpeechToText: true,
        source: 'assemblyai',
        durationSeconds: pollData.audio_duration ? Math.round(pollData.audio_duration) : null,
        segments,
        totalSegments: segments.length,
      });
    }

    if (pollData.status === 'error') {
      return res.status(500).json({
        status: 'error',
        error: pollData.error || 'Transcription failed',
      });
    }

    // Still processing
    return res.status(200).json({
      status: pollData.status, // 'queued' or 'processing'
      message: 'Still processing...',
    });

  } catch (error) {
    return res.status(500).json({ error: 'Poll request failed' });
  }
}

function groupWordsIntoSegments(words, fullText) {
  if (!words || words.length === 0) {
    if (fullText) return [{ start: 0, duration: 0, text: fullText }];
    return [];
  }

  const segments = [];
  let currentSeg = null;

  for (const word of words) {
    const needsNew =
      !currentSeg ||
      currentSeg.wordCount >= 18 ||
      (word.start - currentSeg.lastEnd) > 1500 ||
      /[.?!]$/.test(currentSeg.text);

    if (needsNew) {
      if (currentSeg) {
        segments.push({
          start: Math.round(currentSeg.start * 100) / 100,
          duration: Math.round(((currentSeg.lastEnd / 1000) - currentSeg.start) * 100) / 100,
          text: currentSeg.text,
        });
      }
      currentSeg = { start: word.start / 1000, text: '', wordCount: 0, lastEnd: word.end };
    }

    currentSeg.text += (currentSeg.text ? ' ' : '') + word.text;
    currentSeg.wordCount++;
    currentSeg.lastEnd = word.end;
  }

  if (currentSeg && currentSeg.text) {
    segments.push({
      start: Math.round(currentSeg.start * 100) / 100,
      duration: Math.round(((currentSeg.lastEnd / 1000) - currentSeg.start) * 100) / 100,
      text: currentSeg.text,
    });
  }

  return segments;
}
